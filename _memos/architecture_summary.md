# アプリケーション・アーキテクチャ概要

このドキュメントは、現在のアプリケーションの主要なアーキテクチャ層と、それらの間のデータの流れ、および設計原則についてまとめたものです。

## 1. 全体像とデータの流れ

アプリケーションは、以下の主要な層に分かれています。

`[Route層]` <-> `DTO` <-> `[Service層]` <-> `ドメインモデル` <-> `[Repository層]` <-> `DB`

各層は明確な責務を持ち、依存関係逆転の原則（Dependency Inversion Principle: DIP）を適用することで、疎結合でテストしやすい構造を実現しています。

## 2. 各層の責務と役割

### 2.1. Route層 (Presentation Layer)
-   **ファイル:** `route/user.py` など
-   **責務:** HTTPリクエストの受付とHTTPレスポンスの返却。アプリケーションの外部インターフェースを提供します。
-   **データの扱い:** Service層から受け取った**DTO (Data Transfer Object)** をJSON形式に変換してクライアントに返します。内部のドメインモデルの詳細は意識しません。
-   **依存関係:** Service層（ただし、直接インスタンス化せず、DIコンテナ経由で取得）。

### 2.2. Service層 (Application/Business Logic Layer)
-   **ファイル:** `services/user_service.py` など
-   **責務:** アプリケーションのユースケース（ビジネスロジック）を実行します。複数のリポジトリを連携させたり、ドメインモデルに定義されたビジネスルールを呼び出したりします。
-   **データの扱い:**
    -   Repository層から**ドメインモデル**を受け取ります。
    -   ビジネスロジックを適用した後、Route層に渡すためにドメインモデルを**DTO**に変換します。
-   **依存関係:**
    -   抽象化されたリポジトリインターフェース（`IUserRepository`）。
    -   ドメインモデル（`User`）。
    -   DTO（`UserResponse`）。

### 2.3. Repository層 (Infrastructure Layer)
-   **ファイル:** `infra/repository/user_repository.py` など
-   **責務:** データ永続化の抽象化。データベースや外部APIとの具体的なやり取りを隠蔽します。
-   **データの扱い:**
    -   データベースから取得した生データを、アプリケーションの核となる**ドメインモデル**に変換してService層に返します。
    -   データベースへの書き込み時には、ドメインモデルを受け取り、データベースに適した形式に変換して永続化します。
-   **依存関係:**
    -   データベースクライアント（`db_client.py`）。
    -   ドメインモデル（`User`）。
    -   **抽象化されたリポジトリインターフェース（`IUserRepository`）を実装します。**

## 3. 主要な設計要素

### 3.1. ドメインモデル (`domain/user_domain.py`)
-   **例:** `User` クラス
-   **役割:** アプリケーションのビジネス領域における「概念」を表現します。ビジネスルールや制約（例: Pydanticのバリデーション）をカプセル化します。
-   **特徴:** Pydantic `BaseModel` を使用し、データの型定義とバリデーションを強力にサポートします。

### 3.2. DTO (Data Transfer Object) (`application/ports/user_dto.py`)
-   **例:** `UserResponse` クラス
-   **役割:** 層間（特にService層とRoute層の間）でデータを転送するための専用オブジェクトです。APIのレスポンス形式とドメインモデルの構造を分離します。
-   **特徴:** Pydantic `BaseModel` を使用し、APIのスキーマ定義としても機能します。ドメインモデルの内部情報（例: パスワードハッシュ）を外部に公開しないように制御できます。

### 3.3. ポートとアダプター (Ports and Adapters / Hexagonal Architecture)
-   **ポート:** `application/ports/user_repository_port.py` で定義された `IUserRepository` のような抽象インターフェース。Service層（アプリケーションコア）は、このポートに依存します。
-   **アダプター:** `infra/repository/user_repository.py` の `UserRepository` のように、ポート（`IUserRepository`）を実装する具体的なクラス。外部の技術（データベース、外部APIなど）との接続を担います。
-   **メリット:** アプリケーションのコア（Service層）がインフラの詳細から完全に独立し、テストが容易になり、インフラ技術の変更に強くなります。

### 3.4. 依存性注入 (Dependency Injection: DI) (`dependencies.py`)
-   **ファイル:** `dependencies.py`
-   **役割:** 各コンポーネントが依存するオブジェクトを、コンポーネント自身が生成するのではなく、外部（DIコンテナ）から注入する仕組みです。
-   **特徴:** Flaskの `g` オブジェクトを利用して、リクエストスコープでのインスタンス管理を行います。これにより、コンポーネント間の結合度が下がり、テスト時のモック化が容易になります。

## 4. まとめ

このアーキテクチャは、各層の責務を明確にし、抽象化と依存性注入を積極的に活用することで、以下のメリットを提供します。

-   **高い保守性:** 各コンポーネントが独立しているため、一部の変更が他の部分に与える影響を最小限に抑えられます。
-   **優れたテスト容易性:** 依存関係が注入されるため、単体テスト時に簡単にモックオブジェクトに差し替えることができます。
-   **柔軟な拡張性:** 新しい機能の追加や、データベースなどのインフラ技術の変更が容易になります。

この設計原則に従うことで、アプリケーションは長期的に見て、より堅牢でスケーラブルなものとなります。
